local M = {}

local ls = require('luasnip')
local s = ls.snippet
local sn = ls.snippet_node
local isn = ls.indent_snippet_node
local t = ls.text_node
local i = ls.insert_node
local f = ls.function_node
local c = ls.choice_node
local d = ls.dynamic_node
local r = ls.restore_node
local events = require('luasnip.util.events')
local ai = require('luasnip.nodes.absolute_indexer')
local extras = require('luasnip.extras')
local l = extras.lambda
local rep = extras.rep
local p = extras.partial
local m = extras.match
local n = extras.nonempty
local dl = extras.dynamic_lambda
local fmt = require('luasnip.extras.fmt').fmt
local fmta = require('luasnip.extras.fmt').fmta
local conds = require('luasnip.extras.expand_conditions')
local postfix = require('luasnip.extras.postfix').postfix
local types = require('luasnip.util.types')
local parse = require('luasnip.util.parser').parse_snippet
local ms = ls.multi_snippet
local k = require('luasnip.nodes.key_indexer').new_key

-- Start dynamic_node with user input
-- https://github.com/L3MON4D3/LuaSnip/wiki/Misc#dynamicnode-with-user-input
local ls = require('luasnip')
local util = require('luasnip.util.util')
local node_util = require('luasnip.nodes.util')

-- My modules
local string_processor = require('luasnippets.functions.string_processor')

local function find_dynamic_node(node)
    -- the dynamicNode-key is set on snippets generated by a dynamicNode only (its'
    -- actual use is to refer to the dynamicNode that generated the snippet).
    while not node.dynamicNode do
        node = node.parent
    end
    return node.dynamicNode
end
local external_update_id = 0

-- end dynamic_node with user input
-- https://github.com/L3MON4D3/LuaSnip/wiki/Misc#dynamicnode-with-user-input
-- func_indx to update the dynamicNode with different functions.
M.dynamic_node_external_update = function(func_indx)
    -- most of this function is about restoring the cursor to the correct
    -- position+mode, the important part are the few lines from
    -- `dynamic_node.snip:store()`.

    -- find current node and the innermost dynamicNode it is inside.
    local current_node = ls.session.current_nodes[vim.api.nvim_get_current_buf()]
    local dynamic_node = find_dynamic_node(current_node)
    if not dynamic_node then
        return nil
    end

    -- to identify current node in new snippet, if it is available.
    external_update_id = external_update_id + 1
    current_node.external_update_id = external_update_id

    -- store which mode we're in to restore later.
    local insert_pre_call = vim.fn.mode() == 'i'
    -- is byte-indexed! Doesn't matter here, but important to be aware of.
    local cursor_pos_pre_relative = util.pos_sub(util.get_cursor_0ind(), current_node.mark:pos_begin_raw())

    -- leave current generated snippet.
    node_util.leave_nodes_between(dynamic_node.snip, current_node)

    -- call update-function.
    local func = dynamic_node.user_args[func_indx]
    if func then
        -- the same snippet passed to the dynamicNode-function. Any output from func
        -- should be stored in it under some unused key.
        func(dynamic_node.parent.snippet)
    end

    -- last_args is used to store the last args that were used to generate the
    -- snippet. If this function is called, these will most probably not have
    -- changed, so they are set to nil, which will force an update.
    dynamic_node.last_args = nil
    dynamic_node:update()

    -- everything below here isn't strictly necessary, but it's pretty nice to have.

    -- try to find the node we marked earlier.
    local target_node = dynamic_node:find_node(function(test_node)
        return test_node.external_update_id == external_update_id
    end)

    if target_node then
        -- the node that the cursor was in when changeChoice was called exists
        -- in the active choice! Enter it and all nodes between it and this choiceNode,
        -- then set the cursor.
        node_util.enter_nodes_between(dynamic_node, target_node)

        if insert_pre_call then
            util.set_cursor_0ind(util.pos_add(target_node.mark:pos_begin_raw(), cursor_pos_pre_relative))
        else
            node_util.select_node(target_node)
        end
        -- set the new current node correctly.
        ls.session.current_nodes[vim.api.nvim_get_current_buf()] = target_node
    else
        -- the marked node wasn't found, just jump into the new snippet noremally.
        ls.session.current_nodes[vim.api.nvim_get_current_buf()] = dynamic_node.snip:jump_into(1)
    end
end

---Function to make printf style functions easier
---@param jump_position integer The node index for this dynamic_node to go
---@param dependent_insert_node_index integer The node index for the insert_node of the main print layout
---@param separator string|nil This optional separator will be used instead of the default ',' if desired
M.printf_style_dynamic_formatter = function(jump_position, dependent_insert_node_index, separator)
    return d(jump_position, function(args, snip)
        if not separator then
            separator = ','
        end

        local output = {}
        local test = (args[1] or {})[1]
        local insert_location = 1
        if test then
            for _, format_modifier in ipairs(string_processor.printf_format_modifier_matcher(test)) do
                table.insert(output, t(separator))
                table.insert(output, i(insert_location, string.format([['%s']], format_modifier)))
                insert_location = insert_location + 1
            end
        end
        return sn(nil, output)
    end, { dependent_insert_node_index })
end

M.wrap_selected_text = function(node_index)
    return d(node_index, function(args, snip)
        local nodes = {}

        -- Check to see if a text selection has been stored
        -- local selected_text = {}
        --[[
        snip.env.LS_SELECT_RAW - really bad indentation

        snip.env.LS_SELECT_RAW
        if  then
            i(1),
        auxiliary.wrap_selected_text(2),
        i(0),
        end

        snip.env.LS_SELECTED_TEXT - does not work as DOC.md says
        ]]
        -- local selected_text_line_count = #snip.env.LS_SELECT_DEDENT
        -- for index, item in ipairs(snip.env.LS_SELECT_DEDENT) do
        --     -- for _, item in ipairs(snip.env.LS_SELECT_RAW) do
        --     table.insert(selected_text, string.rep(' ', vim.bo.shiftwidth) .. item)
        --     if index == selected_text_line_count then
        --         table.insert(selected_text, '')
        --     end
        -- end

        -- -- Add nodes for snippet
        -- table.insert(nodes, t(selected_text))
        -- table.insert(nodes, t(string.rep(' ', vim.bo.shiftwidth)))
        -- local selected
        -- if  then
        --
        -- end

        table.insert(nodes, t(snip.env.LS_SELECT_DEDENT))
        table.insert(nodes, i(1))

        -- local position = vim.api.nvim_win_get_cursor(0)

        -- return isn(nil, nodes, string.rep(' ', vim.bo.shiftwidth + vim.bo.shiftwidth * position[2]))
        -- return isn(nil, nodes, '$PARENT_INDENT')
        -- return isn(nil, nodes, '$PARENT_INDENT' .. string.rep(' ',vim.bo.shiftwidth))
        vim.defer_fn(function()
            vim.cmd('w')
        end, 2000)
        vim.defer_fn(function()
            vim.lsp.buf.format({ async = true })
        end, 5000)
        return sn(nil, nodes)
    end, {})
end

---Function for luasnip to add using directives needed for snippets
---@param include_items string|table
M.insert_include_if_needed = function(include_items)
    V('adding')
    if type(include_items) == 'string' then
        local temp = include_items
        include_items = { temp }
    end

    local lines = vim.api.nvim_buf_get_lines(0, 0, -1, false)
    for _, line in ipairs(lines) do
        for index, using_directive in ipairs(include_items) do
            if line:match(using_directive) ~= nil then
                table.remove(include_items, index)
            end
        end
    end

    -- Add all using directives that remain in the list to be written to top of file
    if #include_items > 0 then
        local filetype_include_format_strings = {
            ['lua'] = [[require ('%s')]],
            ['c'] = [[#include %s]],
            ['cs'] = [[using %s;]],
            ['fsharp'] = [[open %s]],
            ['python'] = [[import %s]],
        }

        local current_filetype = vim.bo.filetype
        local current_filetype_format_string = filetype_include_format_strings[current_filetype]

        if not current_filetype_format_string then
            vim.notify(
                string.format('Filetype [%s] not supported with this include function', current_filetype),
                vim.log.levels.ERROR,
                { title = 'Stimpack Notification' }
            )
            return
        end

        local includes_to_write = {}
        for _, include in ipairs(include_items) do
            table.insert(includes_to_write, string.format(current_filetype_format_string, include))
        end
        vim.api.nvim_buf_set_lines(0, 0, 0, false, includes_to_write)
    end
end

return M
